from typing import TYPE_CHECKING, Any, Literal, NotRequired, TypedDict

from rotkehlchen.accounting.mixins.event import AccountingEventType
from rotkehlchen.assets.asset import Asset
from rotkehlchen.constants import ZERO
from rotkehlchen.constants.location_details import get_formatted_location_name
from rotkehlchen.errors.serialization import DeserializationError
from rotkehlchen.history.events.structures.base import (
    HistoryBaseEntry,
    HistoryBaseEntryData,
    HistoryBaseEntryType,
)
from rotkehlchen.history.events.structures.types import HistoryEventSubType, HistoryEventType
from rotkehlchen.serialization.deserialize import deserialize_fval
from rotkehlchen.types import AssetAmount, Location, TimestampMS

from .base import HISTORY_EVENT_DB_TUPLE_WRITE
from .onchain_event import CHAIN_EVENT_FIELDS_TYPE

if TYPE_CHECKING:
    from more_itertools import peekable

    from rotkehlchen.accounting.mixins.event import AccountingEventMixin
    from rotkehlchen.accounting.pot import AccountingPot
    from rotkehlchen.fval import FVal
    from rotkehlchen.types import Price


class SwapEventExtraData(TypedDict):
    """Typed dict with all the valid fields used in extra_data for SwapEvents"""
    # Internal reference used in exchanges.
    reference: NotRequired[str]


class SwapEventEntryData(TypedDict):
    """Typed dict of attributes common to both SwapEvents and EvmSwapEvents.
     Used during deserialization.
     """
    timestamp: TimestampMS
    location: Location
    event_subtype: Literal[
        HistoryEventSubType.SPEND,
        HistoryEventSubType.RECEIVE,
        HistoryEventSubType.FEE,
    ]
    asset: Asset
    amount: 'FVal'
    location_label: str | None
    identifier: int | None
    event_identifier: str | None
    notes: str | None
    extra_data: dict[str, Any] | None


class SwapEvent(HistoryBaseEntry):
    """Swap event representing trades on exchanges, defi, and more."""

    def __init__(
            self,
            timestamp: TimestampMS,
            location: Location,
            event_subtype: Literal[
                HistoryEventSubType.SPEND,
                HistoryEventSubType.RECEIVE,
                HistoryEventSubType.FEE,
            ],
            asset: Asset,
            amount: 'FVal',
            event_identifier: str,
            identifier: int | None = None,
            location_label: str | None = None,
            notes: str | None = None,
            extra_data: SwapEventExtraData | None = None,
    ):
        """An event representing part of a swap (spend/receive/fee).

        `event_subtype`: Event subtype determining which part of the swap this event represents.
        `notes`: Notes specified by the user. Appended to the autogenerated notes.
        """
        super().__init__(
            event_identifier=event_identifier,
            sequence_index={
                HistoryEventSubType.SPEND: 0,
                HistoryEventSubType.RECEIVE: 1,
                HistoryEventSubType.FEE: 2,
            }[event_subtype],
            timestamp=timestamp,
            location=location,
            event_type=HistoryEventType.TRADE,
            event_subtype=event_subtype,
            asset=asset,
            amount=amount,
            location_label=location_label,
            notes=notes,
            identifier=identifier,
            extra_data=extra_data,
        )

    @property
    def entry_type(self) -> HistoryBaseEntryType:
        return HistoryBaseEntryType.SWAP_EVENT

    def serialize_for_db(self) -> tuple[tuple[str, str, HISTORY_EVENT_DB_TUPLE_WRITE]] | tuple[
            tuple[str, str, HISTORY_EVENT_DB_TUPLE_WRITE],
            tuple[str, str, CHAIN_EVENT_FIELDS_TYPE],
    ]:
        return (self._serialize_base_tuple_for_db(),)

    @classmethod
    def deserialize_from_db(cls: type['SwapEvent'], entry: tuple) -> 'SwapEvent':
        """Deserialize a SwapEvent DB tuple.
        May raise:
        - DeserializationError
        - UnknownAsset
        But these exceptions shouldn't normally happen since
        the data from the db should already be correct.
        """
        amount = deserialize_fval(entry[7], 'amount', 'swap event')
        return cls(
            identifier=entry[0],
            event_identifier=entry[1],
            timestamp=TimestampMS(entry[3]),
            location=Location.deserialize_from_db(entry[4]),
            location_label=entry[5],
            event_subtype=HistoryEventSubType.deserialize(entry[10]),  # type: ignore  # should always be correct from the DB
            asset=Asset(entry[6]).check_existence(),
            amount=amount,
            extra_data=cls.deserialize_extra_data(entry=entry, extra_data=entry[11]),
            notes=entry[8] or None,
        )

    def serialize(self) -> dict[str, Any]:
        """Serialize the event for api, and generate the auto_notes.
        May raise UnknownAsset, but this would be an edge case as the asset should already have
        been checked for existence when it was deserialized from an API or from the database.
        """
        serialized_data = super().serialize()
        location_name = get_formatted_location_name(self.location)
        asset_symbol = self.asset.symbol_or_name()
        if self.event_subtype == HistoryEventSubType.SPEND:
            auto_notes = f'Swap {self.amount} {asset_symbol} in {location_name}'
        elif self.event_subtype == HistoryEventSubType.RECEIVE:
            auto_notes = f'Receive {self.amount} {asset_symbol} after a swap in {location_name}'
        else:  # Fee
            auto_notes = f'Spend {self.amount} {asset_symbol} as {location_name} swap fee'

        serialized_data['auto_notes'] = auto_notes
        return serialized_data

    @classmethod
    def _deserialize_swap_data(
            cls: type['SwapEvent'],
            base_data: HistoryBaseEntryData,
    ) -> SwapEventEntryData:
        if (event_subtype := base_data['event_subtype']) not in {
            HistoryEventSubType.SPEND,
            HistoryEventSubType.RECEIVE,
            HistoryEventSubType.FEE,
        }:
            raise DeserializationError(
                f'Unsupported swap event subtype {event_subtype}. '
                f'Expected SPEND, RECEIVE or FEE',
            )

        return SwapEventEntryData(
            identifier=base_data['identifier'],
            event_identifier=base_data['event_identifier'],
            timestamp=base_data['timestamp'],
            location=base_data['location'],
            event_subtype=event_subtype,  # type: ignore  # just confirmed it's a SPEND, RECEIVE or FEE above
            asset=base_data['asset'],
            amount=base_data['amount'],
            notes=base_data['notes'],
            location_label=base_data['location_label'],
            extra_data=base_data['extra_data'],
        )

    @classmethod
    def deserialize(cls: type['SwapEvent'], data: dict[str, Any]) -> 'SwapEvent':
        return cls(**cls._deserialize_swap_data(  # type: ignore[arg-type]  # deserialized extra_data should be valid SwapEventExtraData
            base_data=cls._deserialize_base_history_data(data),
        ))

    def __repr__(self) -> str:
        return f'SwapEvent({", ".join(self._history_base_entry_repr_fields())})'

    # -- Methods of AccountingEventMixin

    @staticmethod
    def get_accounting_event_type() -> AccountingEventType:
        return AccountingEventType.TRADE

    def process(
            self,
            accounting: 'AccountingPot',
            events_iterator: "peekable['AccountingEventMixin']",  # pylint: disable=unused-argument
    ) -> int:
        return accounting.events_accountant.process(self, events_iterator)


def create_swap_events(
        timestamp: TimestampMS,
        location: Location,
        spend: AssetAmount,
        receive: AssetAmount,
        event_identifier: str,
        fee: AssetAmount | None = None,
        location_label: str | None = None,
        spend_notes: str | None = None,
        receive_notes: str | None = None,
        fee_notes: str | None = None,
        identifier: int | None = None,
        receive_identifier: int | None = None,
        fee_identifier: int | None = None,
        extra_data: SwapEventExtraData | None = None,
) -> list[SwapEvent]:
    """Create spend, receive, and optionally fee SwapEvents for a single trade.
    Returns the new SwapEvents in a list.
    """
    events = [SwapEvent(
        timestamp=timestamp,
        location=location,
        event_subtype=HistoryEventSubType.SPEND,
        asset=spend.asset,
        amount=spend.amount,
        location_label=location_label,
        notes=spend_notes,
        identifier=identifier,
        event_identifier=event_identifier,
        extra_data=extra_data,
    ), SwapEvent(
        timestamp=timestamp,
        location=location,
        event_subtype=HistoryEventSubType.RECEIVE,
        asset=receive.asset,
        amount=receive.amount,
        location_label=location_label,
        notes=receive_notes,
        identifier=receive_identifier,
        event_identifier=event_identifier,
    )]
    if fee is not None and fee.amount != ZERO:
        events.append(SwapEvent(
            timestamp=timestamp,
            location=location,
            event_subtype=HistoryEventSubType.FEE,
            asset=fee.asset,
            amount=fee.amount,
            location_label=location_label,
            notes=fee_notes,
            identifier=fee_identifier,
            event_identifier=event_identifier,
        ))

    return events


def deserialize_trade_type_is_buy(value: str) -> bool:
    """Deserialize trade type from raw exchange api or csv value.
    Returns True if trade is a buy, or False if it's a sell.
    May raise DeserializationError if an unexpected value is encountered.
    """
    if (sanitized_value := value.strip().lower()) in {'buy', 'limit_buy', 'settlement_buy', 'settlement buy'}:  # noqa: E501
        return True
    elif sanitized_value in {'sell', 'limit_sell', 'settlement_sell', 'settlement sell'}:
        return False

    raise DeserializationError(f'Failed to deserialize swap side from {value} entry')


def get_swap_spend_receive(
        is_buy: bool,
        base_asset: Asset,
        quote_asset: Asset,
        amount: 'FVal',
        rate: 'Price',
) -> tuple[AssetAmount, AssetAmount]:
    """Calculates amounts and assets spent and received depending on the is_buy flag.
    Returns the spend asset amount and receive asset amount in a tuple.
    """
    base = AssetAmount(asset=base_asset, amount=amount)
    quote = AssetAmount(asset=quote_asset, amount=amount * rate)
    return (quote, base) if is_buy else (base, quote)
