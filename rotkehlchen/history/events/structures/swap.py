from typing import TYPE_CHECKING, Any, Literal, NotRequired, TypedDict

from rotkehlchen.accounting.mixins.event import AccountingEventType
from rotkehlchen.assets.asset import Asset
from rotkehlchen.constants import ZERO
from rotkehlchen.constants.location_details import get_formatted_location_name
from rotkehlchen.errors.serialization import DeserializationError
from rotkehlchen.history.events.structures.base import (
    HistoryBaseEntry,
    HistoryBaseEntryData,
    HistoryBaseEntryType,
)
from rotkehlchen.history.events.structures.types import HistoryEventSubType, HistoryEventType
from rotkehlchen.history.events.utils import create_event_identifier
from rotkehlchen.serialization.deserialize import deserialize_fval
from rotkehlchen.types import AssetAmount, Location, TimestampMS

from .base import HISTORY_EVENT_DB_TUPLE_WRITE
from .evm_event import EVM_EVENT_FIELDS

if TYPE_CHECKING:
    from more_itertools import peekable

    from rotkehlchen.accounting.mixins.event import AccountingEventMixin
    from rotkehlchen.accounting.pot import AccountingPot
    from rotkehlchen.fval import FVal
    from rotkehlchen.types import Price


class SwapEventExtraData(TypedDict):
    """Typed dict with all the valid fields used in extra_data for SwapEvents"""
    # Internal reference used in exchanges.
    reference: NotRequired[str]


class SwapEventEntryData(TypedDict):
    """Typed dict of attributes common to both SwapEvents and EvmSwapEvents.
     Used during deserialization.
     """
    timestamp: TimestampMS
    location: Location
    event_subtype: Literal[
        HistoryEventSubType.SPEND,
        HistoryEventSubType.RECEIVE,
        HistoryEventSubType.FEE,
    ]
    asset: Asset
    amount: 'FVal'
    location_label: str | None
    identifier: int | None
    event_identifier: str | None
    notes: str | None
    extra_data: dict[str, Any] | None


class SwapEvent(HistoryBaseEntry):
    """Swap event representing trades on exchanges, defi, and more."""

    def __init__(
            self,
            timestamp: TimestampMS,
            location: Location,
            event_subtype: Literal[
                HistoryEventSubType.SPEND,
                HistoryEventSubType.RECEIVE,
                HistoryEventSubType.FEE,
            ],
            asset: Asset,
            amount: 'FVal',
            identifier: int | None = None,
            event_identifier: str | None = None,
            unique_id: str | None = None,
            location_label: str | None = None,
            notes: str | None = None,
            extra_data: SwapEventExtraData | None = None,
    ):
        """An event representing part of a swap (spend/receive/fee).

        `event_subtype`: Event subtype determining which part of the swap this event represents.
        `unique_id`: Unique identifier for this swap. Used in conjunction with location
            to generate the event identifier.
        `notes`: Notes specified by the user. Appended to the autogenerated notes.
        """
        super().__init__(
            event_identifier=event_identifier if event_identifier is not None else create_event_identifier(  # noqa: E501
                location=location,
                timestamp=timestamp,
                asset=asset,
                amount=amount,
                unique_id=unique_id,
            ),
            sequence_index={
                HistoryEventSubType.SPEND: 0,
                HistoryEventSubType.RECEIVE: 1,
                HistoryEventSubType.FEE: 2,
            }[event_subtype],
            timestamp=timestamp,
            location=location,
            event_type=HistoryEventType.TRADE,
            event_subtype=event_subtype,
            asset=asset,
            amount=amount,
            location_label=location_label,
            notes=notes,
            identifier=identifier,
            extra_data=extra_data,
        )

    @property
    def entry_type(self) -> HistoryBaseEntryType:
        return HistoryBaseEntryType.SWAP_EVENT

    def serialize_for_db(self) -> tuple[tuple[str, str, HISTORY_EVENT_DB_TUPLE_WRITE]] | tuple[
            tuple[str, str, HISTORY_EVENT_DB_TUPLE_WRITE],
            tuple[str, str, EVM_EVENT_FIELDS],
    ]:
        return (self._serialize_base_tuple_for_db(),)

    @classmethod
    def deserialize_from_db(cls: type['SwapEvent'], entry: tuple) -> 'SwapEvent':
        """Deserialize a SwapEvent DB tuple.
        May raise:
        - DeserializationError
        - UnknownAsset
        But these exceptions shouldn't normally happen since
        the data from the db should already be correct.
        """
        amount = deserialize_fval(entry[7], 'amount', 'swap event')
        return cls(
            identifier=entry[0],
            event_identifier=entry[1],
            timestamp=TimestampMS(entry[3]),
            location=Location.deserialize_from_db(entry[4]),
            location_label=entry[5],
            event_subtype=HistoryEventSubType.deserialize(entry[10]),  # type: ignore  # should always be correct from the DB
            asset=Asset(entry[6]).check_existence(),
            amount=amount,
            extra_data=cls.deserialize_extra_data(entry=entry, extra_data=entry[11]),
            notes=entry[8] or None,
        )

    def _generate_auto_notes(self) -> str:
        """Generate a description of this event. Used in serialize().
        May raise UnknownAsset, but this would be an edge case as the asset should already have
        been checked for existence when it was deserialized from an API or from the database.
        """
        location_name = get_formatted_location_name(self.location)
        asset_symbol = self.asset.symbol_or_name()
        if self.event_subtype == HistoryEventSubType.SPEND:
            return f'Swap {self.amount} {asset_symbol} in {location_name}'
        elif self.event_subtype == HistoryEventSubType.RECEIVE:
            return f'Receive {self.amount} {asset_symbol} after a swap in {location_name}'
        else:  # Fee
            return f'Spend {self.amount} {asset_symbol} as {location_name} swap fee'

    def serialize(self) -> dict[str, Any]:
        """Serialize the event for api."""
        serialized_data = super().serialize()
        serialized_data['auto_notes'] = self._generate_auto_notes()
        return serialized_data

    @classmethod
    def _deserialize_swap_data(
            cls: type['SwapEvent'],
            base_data: HistoryBaseEntryData,
    ) -> SwapEventEntryData:
        if (event_subtype := base_data['event_subtype']) not in {
            HistoryEventSubType.SPEND,
            HistoryEventSubType.RECEIVE,
            HistoryEventSubType.FEE,
        }:
            raise DeserializationError(
                f'Unsupported swap event subtype {event_subtype}. '
                f'Expected SPEND, RECEIVE or FEE',
            )

        return SwapEventEntryData(
            identifier=base_data['identifier'],
            event_identifier=base_data['event_identifier'],
            timestamp=base_data['timestamp'],
            location=base_data['location'],
            event_subtype=event_subtype,  # type: ignore  # just confirmed it's a SPEND, RECEIVE or FEE above
            asset=base_data['asset'],
            amount=base_data['amount'],
            notes=base_data['notes'],
            location_label=base_data['location_label'],
            extra_data=base_data['extra_data'],
        )

    @classmethod
    def deserialize(cls: type['SwapEvent'], data: dict[str, Any]) -> 'SwapEvent':
        return cls(**cls._deserialize_swap_data(  # type: ignore[arg-type]  # deserialized extra_data should be valid SwapEventExtraData
            base_data=cls._deserialize_base_history_data(data),
        ))

    def __repr__(self) -> str:
        return f'SwapEvent({", ".join(self._history_base_entry_repr_fields())})'

    # -- Methods of AccountingEventMixin

    @staticmethod
    def get_accounting_event_type() -> AccountingEventType:
        return AccountingEventType.TRADE

    def process(
            self,
            accounting: 'AccountingPot',
            events_iterator: "peekable['AccountingEventMixin']",  # pylint: disable=unused-argument
    ) -> int:
        return accounting.events_accountant.process(self, events_iterator)


def create_swap_events(
        timestamp: TimestampMS,
        location: Location,
        spend: AssetAmount,
        receive: AssetAmount,
        fee: AssetAmount | None = None,
        location_label: str | None = None,
        unique_id: str | None = None,
        spend_notes: str | None = None,
        receive_notes: str | None = None,
        fee_notes: str | None = None,
        identifier: int | None = None,
        receive_identifier: int | None = None,
        fee_identifier: int | None = None,
        event_identifier: str | None = None,
        extra_data: SwapEventExtraData | None = None,
) -> list[SwapEvent]:
    """Create spend, receive, and optionally fee SwapEvents for a single trade.
    Returns the new SwapEvents in a list.
    """
    events = [SwapEvent(
        timestamp=timestamp,
        location=location,
        event_subtype=HistoryEventSubType.SPEND,
        asset=spend.asset,
        amount=spend.amount,
        unique_id=unique_id,
        location_label=location_label,
        notes=spend_notes,
        identifier=identifier,
        event_identifier=event_identifier,
        extra_data=extra_data,
    ), SwapEvent(
        timestamp=timestamp,
        location=location,
        event_subtype=HistoryEventSubType.RECEIVE,
        asset=receive.asset,
        amount=receive.amount,
        unique_id=unique_id,
        location_label=location_label,
        notes=receive_notes,
        identifier=receive_identifier,
        event_identifier=event_identifier,
    )]
    if fee is not None and fee.amount != ZERO:
        events.append(SwapEvent(
            timestamp=timestamp,
            location=location,
            event_subtype=HistoryEventSubType.FEE,
            asset=fee.asset,
            amount=fee.amount,
            unique_id=unique_id,
            location_label=location_label,
            notes=fee_notes,
            identifier=fee_identifier,
            event_identifier=event_identifier,
        ))

    return events


def get_swap_spend_receive(
        raw_trade_type: str,
        base_asset: Asset,
        quote_asset: Asset,
        amount: 'FVal',
        rate: 'Price',
) -> tuple[AssetAmount, AssetAmount]:
    """Deserialize the trade type and calculate amounts and assets spent and received.
    Returns spend_asset, spend_amount, receive_asset, and receive_amount in a tuple.
    May raise DeserializationError if raw_trade_type has an unexpected value.
    """
    base = AssetAmount(asset=base_asset, amount=amount)
    quote = AssetAmount(asset=quote_asset, amount=amount * rate)
    if (sanitized_symbol := raw_trade_type.strip().lower()) in {'buy', 'limit_buy', 'settlement_buy', 'settlement buy'}:  # noqa: E501
        return quote, base
    elif sanitized_symbol in {'sell', 'limit_sell', 'settlement_sell', 'settlement sell'}:
        return base, quote

    raise DeserializationError(f'Failed to deserialize trade type from {type(raw_trade_type)} entry')  # noqa: E501
