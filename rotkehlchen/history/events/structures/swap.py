from typing import TYPE_CHECKING, Any, Literal, overload

from rotkehlchen.accounting.mixins.event import AccountingEventType
from rotkehlchen.assets.asset import Asset
from rotkehlchen.constants.location_details import get_formatted_location_name
from rotkehlchen.errors.serialization import DeserializationError
from rotkehlchen.history.events.structures.base import HistoryBaseEntry, HistoryBaseEntryType
from rotkehlchen.history.events.structures.types import HistoryEventSubType, HistoryEventType
from rotkehlchen.history.events.utils import create_event_identifier
from rotkehlchen.serialization.deserialize import deserialize_fval
from rotkehlchen.types import AssetAmount, Location, TimestampMS

from .base import HISTORY_EVENT_DB_TUPLE_WRITE

if TYPE_CHECKING:
    from more_itertools import peekable

    from rotkehlchen.accounting.mixins.event import AccountingEventMixin
    from rotkehlchen.accounting.pot import AccountingPot
    from rotkehlchen.fval import FVal
    from rotkehlchen.types import Price


class SwapEvent(HistoryBaseEntry):
    """Swap event representing trades on exchanges, defi, and more."""

    def __init__(
            self,
            timestamp: TimestampMS,
            location: Location,
            event_subtype: Literal[
                HistoryEventSubType.SPEND,
                HistoryEventSubType.RECEIVE,
                HistoryEventSubType.FEE,
            ],
            asset: Asset,
            amount: 'FVal',
            identifier: int | None = None,
            event_identifier: str | None = None,
            unique_id: str | None = None,
            location_label: str | None = None,
            notes: str | None = None,
    ):
        """An event representing part of a swap (spend/receive/fee).

        `event_subtype`: Event subtype determining which part of the swap this event represents.
        `unique_id`: Unique identifier for this swap. Used in conjunction with location
            to generate the event identifier.
        `notes`: Notes specified by the user. Appended to the autogenerated notes.
        """
        super().__init__(
            event_identifier=event_identifier if event_identifier is not None else create_event_identifier(  # noqa: E501
                location=location,
                timestamp=timestamp,
                asset=asset,
                amount=amount,
                unique_id=unique_id,
            ),
            sequence_index={
                HistoryEventSubType.SPEND: 0,
                HistoryEventSubType.RECEIVE: 1,
                HistoryEventSubType.FEE: 2,
            }[event_subtype],
            timestamp=timestamp,
            location=location,
            event_type=HistoryEventType.TRADE,
            event_subtype=event_subtype,
            asset=asset,
            amount=amount,
            location_label=location_label,
            notes=notes,
            identifier=identifier,
        )

    @property
    def entry_type(self) -> HistoryBaseEntryType:
        return HistoryBaseEntryType.SWAP_EVENT

    def serialize_for_db(self) -> tuple[tuple[str, str, HISTORY_EVENT_DB_TUPLE_WRITE]]:
        return (self._serialize_base_tuple_for_db(),)

    @classmethod
    def deserialize_from_db(cls: type['SwapEvent'], entry: tuple) -> 'SwapEvent':
        """Deserialize a SwapEvent DB tuple.
        May raise:
        - DeserializationError
        - UnknownAsset
        But these exceptions shouldn't normally happen since
        the data from the db should already be correct.
        """
        amount = deserialize_fval(entry[7], 'amount', 'swap event')
        return cls(
            identifier=entry[0],
            event_identifier=entry[1],
            timestamp=TimestampMS(entry[3]),
            location=Location.deserialize_from_db(entry[4]),
            location_label=entry[5],
            event_subtype=HistoryEventSubType.deserialize(entry[10]),  # type: ignore  # should always be correct from the DB
            asset=Asset(entry[6]).check_existence(),
            amount=amount,
            notes=entry[8] or None,
        )

    def serialize(self) -> dict[str, Any]:
        """Serialize the event for api.
        Autogenerates the event notes, appending any notes added by the user in a second sentence.
        May raise UnknownAsset, but this would be an edge case as the asset should already have
        been checked for existence when it was deserialized from an API or from the database.
        """
        serialized_data = super().serialize()
        location_name = get_formatted_location_name(self.location)
        asset_symbol = self.asset.symbol_or_name()
        if self.event_subtype == HistoryEventSubType.SPEND:
            description = f'Swap {self.amount} {asset_symbol} in {location_name}'
        elif self.event_subtype == HistoryEventSubType.RECEIVE:
            description = f'Receive {self.amount} {asset_symbol} after a swap in {location_name}'
        else:  # Fee
            description = f'Spend {self.amount} {asset_symbol} as {location_name} swap fee'

        serialized_data['description'] = description
        return serialized_data

    @classmethod
    def deserialize(cls: type['SwapEvent'], data: dict[str, Any]) -> 'SwapEvent':
        base_data = cls._deserialize_base_history_data(data)
        if (event_subtype := base_data['event_subtype']) not in {
            HistoryEventSubType.SPEND,
            HistoryEventSubType.RECEIVE,
            HistoryEventSubType.FEE,
        }:
            raise DeserializationError(
                f'Unsupported swap event subtype {event_subtype}. '
                f'Expected SPEND, RECEIVE or FEE',
            )

        return cls(
            identifier=base_data['identifier'],
            event_identifier=base_data['event_identifier'],
            timestamp=base_data['timestamp'],
            location=base_data['location'],
            location_label=base_data['location_label'],
            event_subtype=event_subtype,  # type: ignore  # just confirmed it's a SPEND, RECEIVE or FEE above
            asset=base_data['asset'],
            amount=base_data['amount'],
        )

    def __repr__(self) -> str:
        return f'SwapEvent({", ".join(self._history_base_entry_repr_fields())})'

    # -- Methods of AccountingEventMixin

    @staticmethod
    def get_accounting_event_type() -> AccountingEventType:
        return AccountingEventType.TRADE

    def process(
            self,
            accounting: 'AccountingPot',
            events_iterator: "peekable['AccountingEventMixin']",  # pylint: disable=unused-argument
    ) -> int:
        return accounting.events_accountant.process(self, events_iterator)


@overload
def create_swap_events(
        timestamp: TimestampMS,
        location: Location,
        spend_asset: Asset,
        spend_amount: 'FVal',
        receive_asset: Asset,
        receive_amount: 'FVal',
        fee_asset: None = None,
        fee_amount: None = None,
        location_label: str | None = None,
        unique_id: str | None = None,
        spend_notes: str | None = None,
        receive_notes: str | None = None,
        fee_notes: str | None = None,
        identifier: int | None = None,
        receive_identifier: int | None = None,
        fee_identifier: int | None = None,
        event_identifier: str | None = None,
) -> list[SwapEvent]:
    """Overload for creating swap events with no fee."""


@overload
def create_swap_events(
        timestamp: TimestampMS,
        location: Location,
        spend_asset: Asset,
        spend_amount: 'FVal',
        receive_asset: Asset,
        receive_amount: 'FVal',
        fee_asset: Asset,
        fee_amount: 'FVal',
        location_label: str | None = None,
        unique_id: str | None = None,
        spend_notes: str | None = None,
        receive_notes: str | None = None,
        fee_notes: str | None = None,
        identifier: int | None = None,
        receive_identifier: int | None = None,
        fee_identifier: int | None = None,
        event_identifier: str | None = None,
) -> list[SwapEvent]:
    """Overload for creating swap events with a fee."""


def create_swap_events(
        timestamp: TimestampMS,
        location: Location,
        spend_asset: Asset,
        spend_amount: 'FVal',
        receive_asset: Asset,
        receive_amount: 'FVal',
        fee_asset: Asset | None = None,
        fee_amount: 'FVal | None' = None,
        location_label: str | None = None,
        unique_id: str | None = None,
        spend_notes: str | None = None,
        receive_notes: str | None = None,
        fee_notes: str | None = None,
        identifier: int | None = None,
        receive_identifier: int | None = None,
        fee_identifier: int | None = None,
        event_identifier: str | None = None,
) -> list[SwapEvent]:
    """Create spend, receive, and optionally fee SwapEvents for a single trade.
    Returns the new SwapEvents in a list.
    """
    events = [SwapEvent(
        timestamp=timestamp,
        location=location,
        event_subtype=HistoryEventSubType.SPEND,
        asset=spend_asset,
        amount=spend_amount,
        unique_id=unique_id,
        location_label=location_label,
        notes=spend_notes,
        identifier=identifier,
        event_identifier=event_identifier,
    ), SwapEvent(
        timestamp=timestamp,
        location=location,
        event_subtype=HistoryEventSubType.RECEIVE,
        asset=receive_asset,
        amount=receive_amount,
        unique_id=unique_id,
        location_label=location_label,
        notes=receive_notes,
        identifier=receive_identifier,
        event_identifier=event_identifier,
    )]
    if fee_asset is not None:
        events.append(SwapEvent(
            timestamp=timestamp,
            location=location,
            event_subtype=HistoryEventSubType.FEE,
            asset=fee_asset,
            amount=fee_amount,  # type: ignore[arg-type]  # Overloads ensure fee_amount is set when fee_asset is.
            unique_id=unique_id,
            location_label=location_label,
            notes=fee_notes,
            identifier=fee_identifier,
            event_identifier=event_identifier,
        ))

    return events


def get_swap_spend_receive(
        raw_trade_type: str,
        base_asset: Asset,
        quote_asset: Asset,
        amount: 'AssetAmount',
        rate: 'Price',
) -> tuple['Asset', 'AssetAmount', 'Asset', 'AssetAmount']:
    """Deserialize the trade type and calculate amounts and assets spent and received.
    Returns spend_asset, spend_amount, receive_asset, and receive_amount in a tuple.
    May raise DeserializationError if raw_trade_type has an unexpected value.
    """
    if (sanitized_symbol := raw_trade_type.strip().lower()) in {'buy', 'limit_buy', 'settlement_buy', 'settlement buy'}:  # noqa: E501
        return quote_asset, AssetAmount(amount * rate), base_asset, amount
    elif sanitized_symbol in {'sell', 'limit_sell', 'settlement_sell', 'settlement sell'}:
        return base_asset, amount, quote_asset, AssetAmount(amount * rate)

    raise DeserializationError(f'Failed to deserialize trade type from {type(raw_trade_type)} entry')  # noqa: E501
