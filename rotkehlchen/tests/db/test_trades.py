from unittest.mock import patch

from rotkehlchen.chain.ethereum.trades import AMMSwap
from rotkehlchen.constants import ONE, ZERO
from rotkehlchen.constants.assets import A_BTC, A_DAI, A_ETH, A_EUR, A_GNO, A_UNI, A_USDC
from rotkehlchen.data_handler import DataHandler
from rotkehlchen.db.filtering import TradesFilterQuery
# from rotkehlchen.db.filtering import TradesFilterQuery
from rotkehlchen.exchanges.data_structures import Trade
from rotkehlchen.fval import FVal
from rotkehlchen.types import Location, Price, TradeType, deserialize_evm_tx_hash
from rotkehlchen.user_messages import MessagesAggregator


def assert_trades_equal(t1: Trade, t2: Trade) -> None:
    """Checks 2 trades are equal. Has a tolerance for precision errors in real numbers
    since the precision generated by sqlite division is different to fval one

    """
    t1_dict = t1.__dict__
    for key, val in t1_dict.items():
        if key in ('rate', 'amount'):
            assert val.is_close(getattr(t2, key))
        else:
            assert val == getattr(t2, key)


def test_query_trades_including_ammswaps(data_dir, username, sql_vm_instructions_cb):
    """Test that querying trades succesfully queries from both the trades and ammswaps"""
    msg_aggregator = MessagesAggregator()
    data = DataHandler(data_dir, msg_aggregator, sql_vm_instructions_cb)
    data.unlock(username, '123', create_new=True)

    trades = [
        Trade(
            timestamp=1,
            location=Location.EXTERNAL,
            base_asset=A_ETH,
            quote_asset=A_USDC,
            trade_type=TradeType.BUY,
            amount=ONE,
            rate=Price(FVal(1.5)),
            fee=None,
            fee_currency=None,
            link='',
            notes=None,
        ), Trade(
            timestamp=2,
            location=Location.KRAKEN,
            base_asset=A_BTC,
            quote_asset=A_EUR,
            trade_type=TradeType.SELL,
            amount=ONE,
            rate=Price(FVal(1.5)),
            fee=None,
            fee_currency=None,
            link='',
            notes=None,
        ), Trade(
            timestamp=3,
            location=Location.POLONIEX,
            base_asset=A_ETH,
            quote_asset=A_EUR,
            trade_type=TradeType.BUY,
            amount=FVal(2),
            rate=Price(FVal(1.5)),
            fee=None,
            fee_currency=None,
            link='',
            notes=None,
        ),
    ]
    swap_1_id = '0x90f68af0ebbbb8d4938a4fbd07a70862e806124abd907d1225f25a10afda0181'
    swap_2_id = '0x90f68af0ebbbb8d4938a4fbd07a70862e806124abd907d1225f25a10afda0182'
    swap_3_id = '0x90f68af0ebbbb8d4938a4fbd07a70862e806124abd907d1225f25a10afda0183'
    swap_4_id = '0x90f68af0ebbbb8d4938a4fbd07a70862e806124abd907d1225f25a10afda0184'
    swap_5_id = '0x90f68af0ebbbb8d4938a4fbd07a70862e806124abd907d1225f25a10afda0185'
    swaps = [
        AMMSwap(
            tx_hash=deserialize_evm_tx_hash(swap_1_id),
            log_index=1,
            address='0xfoo',
            from_address='0xfrom',
            to_address='0xto',
            timestamp=2,
            location=Location.UNISWAP,
            token0=A_DAI,
            token1=A_USDC,
            amount0_in=ONE,
            amount1_in=ZERO,
            amount0_out=ZERO,
            amount1_out=FVal(2),
        ), AMMSwap(
            tx_hash=deserialize_evm_tx_hash(swap_2_id),
            log_index=2,
            address='0xfoo',
            from_address='0xfrom',
            to_address='0xto',
            timestamp=3,
            location=Location.BALANCER,
            token0=A_UNI,
            token1=A_USDC,
            amount0_in=ONE,
            amount1_in=ZERO,
            amount0_out=ZERO,
            amount1_out=FVal(1.5),
        ), AMMSwap(
            tx_hash=deserialize_evm_tx_hash(swap_2_id),
            log_index=3,
            address='0xfoo',
            from_address='0xfrom',
            to_address='0xto',
            timestamp=3,
            location=Location.BALANCER,
            token0=A_USDC,
            token1=A_DAI,
            amount0_in=FVal(1.5),
            amount1_in=ZERO,
            amount0_out=ZERO,
            amount1_out=FVal(3.5),
        ), AMMSwap(
            tx_hash=deserialize_evm_tx_hash(swap_3_id),
            log_index=1,
            address='0xfoo',
            from_address='0xfrom',
            to_address='0xto',
            timestamp=4,
            location=Location.SUSHISWAP,
            token0=A_UNI,
            token1=A_DAI,
            amount0_in=ZERO,
            amount1_in=FVal(2),
            amount0_out=FVal(5),
            amount1_out=ZERO,
        ), AMMSwap(
            tx_hash=deserialize_evm_tx_hash(swap_3_id),
            log_index=2,
            address='0xfoo',
            from_address='0xfrom',
            to_address='0xto',
            timestamp=4,
            location=Location.SUSHISWAP,
            token0=A_DAI,
            token1=A_USDC,
            amount0_in=FVal(5),
            amount1_in=ZERO,
            amount0_out=ZERO,
            amount1_out=FVal(4.95),
        ), AMMSwap(
            tx_hash=deserialize_evm_tx_hash(swap_3_id),
            log_index=3,
            address='0xfoo',
            from_address='0xfrom',
            to_address='0xto',
            timestamp=4,
            location=Location.SUSHISWAP,
            token0=A_GNO,
            token1=A_USDC,
            amount0_in=ZERO,
            amount1_in=FVal(4.95),
            amount0_out=FVal(8.2),
            amount1_out=ZERO,
        ), AMMSwap(
            tx_hash=deserialize_evm_tx_hash(swap_4_id),
            log_index=5,
            address='0xfoo',
            from_address='0xfrom',
            to_address='0xto',
            timestamp=11,
            location=Location.UNISWAP,
            token0=A_GNO,
            token1=A_USDC,
            amount0_in=FVal(5),
            amount1_in=FVal(6),
            amount0_out=ZERO,
            amount1_out=FVal(4.95),
        ), AMMSwap(
            tx_hash=deserialize_evm_tx_hash(swap_4_id),
            log_index=10,
            address='0xfoo',
            from_address='0xfrom',
            to_address='0xto',
            timestamp=11,
            location=Location.UNISWAP,
            token0=A_USDC,
            token1=A_UNI,
            amount0_in=FVal(4.95),
            amount1_in=ZERO,
            amount0_out=ZERO,
            amount1_out=FVal(5.4),
        ), AMMSwap(
            tx_hash=deserialize_evm_tx_hash(swap_5_id),
            log_index=1,
            address='0xfoo',
            from_address='0xfrom',
            to_address='0xto',
            timestamp=14,
            location=Location.SUSHISWAP,
            token0=A_UNI,
            token1=A_USDC,
            amount0_in=FVal(4.5),
            amount1_in=FVal(6),
            amount0_out=ZERO,
            amount1_out=FVal(3.2),
        ), AMMSwap(
            tx_hash=deserialize_evm_tx_hash(swap_5_id),
            log_index=3,
            address='0xfoo',
            from_address='0xfrom',
            to_address='0xto',
            timestamp=14,
            location=Location.SUSHISWAP,
            token0=A_USDC,
            token1=A_GNO,
            amount0_in=FVal(5.55),
            amount1_in=ZERO,
            amount0_out=FVal(2.15),
            amount1_out=FVal(5.4),
        ),
    ]
    with data.db.user_write() as cursor:
        data.db.add_trades(cursor, trades)
        data.db.add_amm_swaps(cursor, swaps)
    swap1_trade = Trade(
        timestamp=swaps[0].timestamp,
        location=swaps[0].location,
        base_asset=swaps[0].token1,
        quote_asset=swaps[0].token0,
        trade_type=TradeType.BUY,
        amount=swaps[0].amount1_out,
        rate=swaps[0].amount0_in / swaps[0].amount1_out,
        fee=None,
        fee_currency=None,
        link=swaps[0].tx_hash.hex(),
        notes=None,
    )
    swap2_trade = Trade(
        timestamp=swaps[1].timestamp,
        location=swaps[1].location,
        base_asset=swaps[2].token1,
        quote_asset=swaps[1].token0,
        trade_type=TradeType.BUY,
        amount=swaps[2].amount1_out,
        rate=swaps[1].amount0_in / swaps[2].amount1_out,
        fee=None,
        fee_currency=None,
        link=swaps[1].tx_hash.hex(),
        notes=None,
    )
    swap3_trade = Trade(
        timestamp=swaps[3].timestamp,
        location=swaps[3].location,
        base_asset=swaps[5].token0,
        quote_asset=swaps[3].token1,
        trade_type=TradeType.BUY,
        amount=swaps[5].amount0_out,
        rate=swaps[3].amount1_in / swaps[5].amount0_out,
        fee=None,
        fee_currency=None,
        link=swaps[3].tx_hash.hex(),
        notes=None,
    )
    swap4_trade1 = Trade(
        timestamp=swaps[6].timestamp,
        location=swaps[6].location,
        base_asset=swaps[7].token1,
        quote_asset=swaps[6].token0,
        trade_type=TradeType.BUY,
        amount=swaps[7].amount1_out / 2,
        rate=swaps[6].amount0_in / (swaps[7].amount1_out / 2),
        fee=None,
        fee_currency=None,
        link=swaps[6].tx_hash.hex(),
        notes=None,
    )
    swap4_trade2 = Trade(
        timestamp=swaps[6].timestamp,
        location=swaps[6].location,
        base_asset=swaps[7].token1,
        quote_asset=swaps[6].token1,
        trade_type=TradeType.BUY,
        amount=swaps[7].amount1_out / 2,
        rate=swaps[6].amount1_in / (swaps[7].amount1_out / 2),
        fee=None,
        fee_currency=None,
        link=swaps[6].tx_hash.hex(),
        notes=None,
    )
    swap5_trade1 = Trade(
        timestamp=swaps[8].timestamp,
        location=swaps[8].location,
        base_asset=swaps[9].token1,
        quote_asset=swaps[8].token1,
        trade_type=TradeType.BUY,
        amount=swaps[9].amount1_out,
        rate=swaps[8].amount1_in / swaps[9].amount1_out,
        fee=None,
        fee_currency=None,
        link=swaps[8].tx_hash.hex(),
        notes=None,
    )
    swap5_trade2 = Trade(
        timestamp=swaps[8].timestamp,
        location=swaps[8].location,
        base_asset=swaps[9].token0,
        quote_asset=swaps[8].token0,
        trade_type=TradeType.BUY,
        amount=swaps[9].amount0_out,
        rate=swaps[8].amount0_in / swaps[9].amount0_out,
        fee=None,
        fee_currency=None,
        link=swaps[8].tx_hash.hex(),
        notes=None,
    )

    # Get all trades
    with data.db.conn.read_ctx() as cursor:
        returned_trades = data.db.get_trades(cursor, filter_query=TradesFilterQuery.make(), has_premium=True)  # noqa: E501
        assert len(returned_trades) == 10
        assert returned_trades[0] == trades[0]
        assert returned_trades[2] == trades[1]
        assert returned_trades[4] == trades[2]
        assert_trades_equal(returned_trades[1], swap1_trade)
        assert_trades_equal(returned_trades[3], swap2_trade)
        assert_trades_equal(returned_trades[5], swap3_trade)
        assert_trades_equal(returned_trades[6], swap4_trade2)
        assert_trades_equal(returned_trades[7], swap4_trade1)
        assert_trades_equal(returned_trades[8], swap5_trade1)
        assert_trades_equal(returned_trades[9], swap5_trade2)

        # Get last 5 trades
        returned_trades = data.db.get_trades(
            cursor,
            filter_query=TradesFilterQuery.make(limit=5, offset=5),
            has_premium=True,
        )
        assert len(returned_trades) == 5
        assert_trades_equal(returned_trades[0], swap3_trade)
        assert_trades_equal(returned_trades[1], swap4_trade2)
        assert_trades_equal(returned_trades[2], swap4_trade1)
        assert_trades_equal(returned_trades[3], swap5_trade1)
        assert_trades_equal(returned_trades[4], swap5_trade2)

        # Get first 5 trades that are in uniswap and that buy USDC
        returned_trades = data.db.get_trades(
            cursor,
            filter_query=TradesFilterQuery.make(
                limit=5, offset=0, location=Location.UNISWAP, base_assets=(A_USDC,),
            ), has_premium=True,
        )
        assert len(returned_trades) == 1
        assert_trades_equal(returned_trades[0], swap1_trade)

        # Get all trades with quote asset USDC
        returned_trades = data.db.get_trades(
            cursor,
            filter_query=TradesFilterQuery.make(quote_assets=(A_USDC,)),
            has_premium=True,
        )
        assert len(returned_trades) == 3
        assert_trades_equal(returned_trades[0], trades[0])
        assert_trades_equal(returned_trades[1], swap4_trade2)
        assert_trades_equal(returned_trades[2], swap5_trade1)

        # Get all trades as non premium user with 2 free trades as limit
        limit_patch = patch(
            target='rotkehlchen.db.dbhandler.FREE_TRADES_LIMIT',
            new=2,
        )
        with limit_patch:
            returned_trades, total_found = data.db.get_trades_and_limit_info(
                cursor,
                filter_query=TradesFilterQuery.make(),
                has_premium=False,
            )
        # trades should be the latest 2
        assert total_found == 3  # the 3 normal trades -- free users don't see swaps
        assert len(returned_trades) == 2
        assert_trades_equal(returned_trades[0], trades[1])
        assert_trades_equal(returned_trades[1], trades[2])

        # Get filtered trades as non premium user with 2 free trades as limit
        limit_patch = patch(
            target='rotkehlchen.db.dbhandler.FREE_TRADES_LIMIT',
            new=2,
        )
        with limit_patch:
            returned_trades, total_found = data.db.get_trades_and_limit_info(
                cursor,
                filter_query=TradesFilterQuery.make(from_ts=1, to_ts=2),
                has_premium=False,
            )
        # trades should be the second one since the free limit includes the last 2 only
        assert total_found == 2, 'total found for filter should be 2'
        assert len(returned_trades) == 1
        assert_trades_equal(returned_trades[0], trades[1])
