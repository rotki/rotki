from unittest.mock import patch

from rotkehlchen.chain.ethereum.trades import AMMSwap
from rotkehlchen.constants import ZERO
from rotkehlchen.constants.assets import A_BTC, A_DAI, A_ETH, A_EUR, A_GNO, A_UNI, A_USDC
from rotkehlchen.data_handler import DataHandler
from rotkehlchen.db.filtering import TradesFilterQuery
# from rotkehlchen.db.filtering import TradesFilterQuery
from rotkehlchen.exchanges.data_structures import Trade
from rotkehlchen.fval import FVal
from rotkehlchen.typing import Location, Price, TradeType
from rotkehlchen.user_messages import MessagesAggregator


def assert_trades_equal(t1: Trade, t2: Trade) -> None:
    """Checks 2 trades are equal. Has a tolerance for precision errors in real numbers
    since the precision generated by sqlite division is different to fval one

    """
    t1_dict = t1._asdict()
    for key, val in t1_dict.items():
        if key in ('rate', 'amount'):
            assert val.is_close(getattr(t2, key))
        else:
            assert val == getattr(t2, key)


def test_query_trades_including_ammswaps(data_dir, username):
    """Test that querying trades succesfully queries from both the trades and ammswaps"""
    msg_aggregator = MessagesAggregator()
    data = DataHandler(data_dir, msg_aggregator)
    data.unlock(username, '123', create_new=True)

    trades = [
        Trade(
            timestamp=1,
            location=Location.EXTERNAL,
            base_asset=A_ETH,
            quote_asset=A_USDC,
            trade_type=TradeType.BUY,
            amount=FVal(1),
            rate=Price(FVal(1.5)),
            fee=None,
            fee_currency=None,
            link='',
            notes=None,
        ), Trade(
            timestamp=2,
            location=Location.KRAKEN,
            base_asset=A_BTC,
            quote_asset=A_EUR,
            trade_type=TradeType.SELL,
            amount=FVal(1),
            rate=Price(FVal(1.5)),
            fee=None,
            fee_currency=None,
            link='',
            notes=None,
        ), Trade(
            timestamp=3,
            location=Location.POLONIEX,
            base_asset=A_ETH,
            quote_asset=A_EUR,
            trade_type=TradeType.BUY,
            amount=FVal(2),
            rate=Price(FVal(1.5)),
            fee=None,
            fee_currency=None,
            link='',
            notes=None,
        ),
    ]
    swaps = [
        AMMSwap(
            tx_hash='0x1',
            log_index=1,
            address='0xfoo',
            from_address='0xfrom',
            to_address='0xto',
            timestamp=2,
            location=Location.UNISWAP,
            token0=A_DAI,
            token1=A_USDC,
            amount0_in=FVal(1),
            amount1_in=ZERO,
            amount0_out=ZERO,
            amount1_out=FVal(2),
        ), AMMSwap(
            tx_hash='0x2',
            log_index=2,
            address='0xfoo',
            from_address='0xfrom',
            to_address='0xto',
            timestamp=3,
            location=Location.BALANCER,
            token0=A_UNI,
            token1=A_USDC,
            amount0_in=FVal(1),
            amount1_in=ZERO,
            amount0_out=ZERO,
            amount1_out=FVal(1.5),
        ), AMMSwap(
            tx_hash='0x2',
            log_index=3,
            address='0xfoo',
            from_address='0xfrom',
            to_address='0xto',
            timestamp=3,
            location=Location.BALANCER,
            token0=A_USDC,
            token1=A_DAI,
            amount0_in=FVal(1.5),
            amount1_in=ZERO,
            amount0_out=ZERO,
            amount1_out=FVal(3.5),
        ), AMMSwap(
            tx_hash='0x3',
            log_index=1,
            address='0xfoo',
            from_address='0xfrom',
            to_address='0xto',
            timestamp=4,
            location=Location.SUSHISWAP,
            token0=A_UNI,
            token1=A_DAI,
            amount0_in=ZERO,
            amount1_in=FVal(2),
            amount0_out=FVal(5),
            amount1_out=ZERO,
        ), AMMSwap(
            tx_hash='0x3',
            log_index=2,
            address='0xfoo',
            from_address='0xfrom',
            to_address='0xto',
            timestamp=4,
            location=Location.SUSHISWAP,
            token0=A_DAI,
            token1=A_USDC,
            amount0_in=FVal(5),
            amount1_in=ZERO,
            amount0_out=ZERO,
            amount1_out=FVal(4.95),
        ), AMMSwap(
            tx_hash='0x3',
            log_index=3,
            address='0xfoo',
            from_address='0xfrom',
            to_address='0xto',
            timestamp=4,
            location=Location.SUSHISWAP,
            token0=A_GNO,
            token1=A_USDC,
            amount0_in=ZERO,
            amount1_in=FVal(4.95),
            amount0_out=FVal(8.2),
            amount1_out=ZERO,
        ), AMMSwap(
            tx_hash='0x4',
            log_index=5,
            address='0xfoo',
            from_address='0xfrom',
            to_address='0xto',
            timestamp=11,
            location=Location.UNISWAP,
            token0=A_GNO,
            token1=A_USDC,
            amount0_in=FVal(5),
            amount1_in=FVal(6),
            amount0_out=ZERO,
            amount1_out=FVal(4.95),
        ), AMMSwap(
            tx_hash='0x4',
            log_index=10,
            address='0xfoo',
            from_address='0xfrom',
            to_address='0xto',
            timestamp=11,
            location=Location.UNISWAP,
            token0=A_USDC,
            token1=A_UNI,
            amount0_in=FVal(4.95),
            amount1_in=ZERO,
            amount0_out=ZERO,
            amount1_out=FVal(5.4),
        ), AMMSwap(
            tx_hash='0x5',
            log_index=1,
            address='0xfoo',
            from_address='0xfrom',
            to_address='0xto',
            timestamp=14,
            location=Location.SUSHISWAP,
            token0=A_UNI,
            token1=A_USDC,
            amount0_in=FVal(4.5),
            amount1_in=FVal(6),
            amount0_out=ZERO,
            amount1_out=FVal(3.2),
        ), AMMSwap(
            tx_hash='0x5',
            log_index=3,
            address='0xfoo',
            from_address='0xfrom',
            to_address='0xto',
            timestamp=14,
            location=Location.SUSHISWAP,
            token0=A_USDC,
            token1=A_GNO,
            amount0_in=FVal(5.55),
            amount1_in=ZERO,
            amount0_out=FVal(2.15),
            amount1_out=FVal(5.4),
        ),
    ]
    data.db.add_trades(trades)
    data.db.add_amm_swaps(swaps)
    swap1_trade = Trade(
        timestamp=swaps[0].timestamp,
        location=swaps[0].location,
        base_asset=swaps[0].token1,
        quote_asset=swaps[0].token0,
        trade_type=TradeType.BUY,
        amount=swaps[0].amount1_out,
        rate=swaps[0].amount0_in / swaps[0].amount1_out,
        fee=None,
        fee_currency=None,
        link=swaps[0].tx_hash,
        notes=None,
    )
    swap2_trade = Trade(
        timestamp=swaps[1].timestamp,
        location=swaps[1].location,
        base_asset=swaps[2].token1,
        quote_asset=swaps[1].token0,
        trade_type=TradeType.BUY,
        amount=swaps[2].amount1_out,
        rate=swaps[1].amount0_in / swaps[2].amount1_out,
        fee=None,
        fee_currency=None,
        link=swaps[1].tx_hash,
        notes=None,
    )
    swap3_trade = Trade(
        timestamp=swaps[3].timestamp,
        location=swaps[3].location,
        base_asset=swaps[5].token0,
        quote_asset=swaps[3].token1,
        trade_type=TradeType.BUY,
        amount=swaps[5].amount0_out,
        rate=swaps[3].amount1_in / swaps[5].amount0_out,
        fee=None,
        fee_currency=None,
        link=swaps[3].tx_hash,
        notes=None,
    )
    swap4_trade1 = Trade(
        timestamp=swaps[6].timestamp,
        location=swaps[6].location,
        base_asset=swaps[7].token1,
        quote_asset=swaps[6].token0,
        trade_type=TradeType.BUY,
        amount=swaps[7].amount1_out / 2,
        rate=swaps[6].amount0_in / (swaps[7].amount1_out / 2),
        fee=None,
        fee_currency=None,
        link=swaps[6].tx_hash,
        notes=None,
    )
    swap4_trade2 = Trade(
        timestamp=swaps[6].timestamp,
        location=swaps[6].location,
        base_asset=swaps[7].token1,
        quote_asset=swaps[6].token1,
        trade_type=TradeType.BUY,
        amount=swaps[7].amount1_out / 2,
        rate=swaps[6].amount1_in / (swaps[7].amount1_out / 2),
        fee=None,
        fee_currency=None,
        link=swaps[6].tx_hash,
        notes=None,
    )
    swap5_trade1 = Trade(
        timestamp=swaps[8].timestamp,
        location=swaps[8].location,
        base_asset=swaps[9].token1,
        quote_asset=swaps[8].token1,
        trade_type=TradeType.BUY,
        amount=swaps[9].amount1_out,
        rate=swaps[8].amount1_in / swaps[9].amount1_out,
        fee=None,
        fee_currency=None,
        link=swaps[8].tx_hash,
        notes=None,
    )
    swap5_trade2 = Trade(
        timestamp=swaps[8].timestamp,
        location=swaps[8].location,
        base_asset=swaps[9].token0,
        quote_asset=swaps[8].token0,
        trade_type=TradeType.BUY,
        amount=swaps[9].amount0_out,
        rate=swaps[8].amount0_in / swaps[9].amount0_out,
        fee=None,
        fee_currency=None,
        link=swaps[8].tx_hash,
        notes=None,
    )

    # Get all trades
    returned_trades = data.db.get_trades(filter_query=TradesFilterQuery.make(), has_premium=True)
    assert len(returned_trades) == 10
    assert returned_trades[0] == trades[0]
    assert returned_trades[2] == trades[1]
    assert returned_trades[4] == trades[2]
    assert_trades_equal(returned_trades[1], swap1_trade)
    assert_trades_equal(returned_trades[3], swap2_trade)
    assert_trades_equal(returned_trades[5], swap3_trade)
    assert_trades_equal(returned_trades[6], swap4_trade2)
    assert_trades_equal(returned_trades[7], swap4_trade1)
    assert_trades_equal(returned_trades[8], swap5_trade1)
    assert_trades_equal(returned_trades[9], swap5_trade2)

    # Get last 5 trades
    returned_trades = data.db.get_trades(
        filter_query=TradesFilterQuery.make(limit=5, offset=5),
        has_premium=True,
    )
    assert len(returned_trades) == 5
    assert_trades_equal(returned_trades[0], swap3_trade)
    assert_trades_equal(returned_trades[1], swap4_trade2)
    assert_trades_equal(returned_trades[2], swap4_trade1)
    assert_trades_equal(returned_trades[3], swap5_trade1)
    assert_trades_equal(returned_trades[4], swap5_trade2)

    # Get first 5 trades that are in uniswap and that buy USDC
    returned_trades = data.db.get_trades(
        filter_query=TradesFilterQuery.make(
            limit=5, offset=0, location=Location.UNISWAP, base_asset=A_USDC,
        ), has_premium=True,
    )
    assert len(returned_trades) == 1
    assert_trades_equal(returned_trades[0], swap1_trade)

    # Get all trades with quote asset USDC
    returned_trades = data.db.get_trades(
        filter_query=TradesFilterQuery.make(quote_asset=A_USDC),
        has_premium=True,
    )
    assert len(returned_trades) == 3
    assert_trades_equal(returned_trades[0], trades[0])
    assert_trades_equal(returned_trades[1], swap4_trade2)
    assert_trades_equal(returned_trades[2], swap5_trade1)

    # Get all trades as non premium user with 2 free trades as limit
    limit_patch = patch(
        target='rotkehlchen.db.dbhandler.FREE_TRADES_LIMIT',
        new=2,
    )
    with limit_patch:
        returned_trades, total_found = data.db.get_trades_and_limit_info(
            filter_query=TradesFilterQuery.make(),
            has_premium=False,
        )
    # trades should be the latest 2
    assert total_found == 3  # the 3 normal trades -- free users don't see swaps
    assert len(returned_trades) == 2
    assert_trades_equal(returned_trades[0], trades[1])
    assert_trades_equal(returned_trades[1], trades[2])

    # Get filtered trades as non premium user with 2 free trades as limit
    limit_patch = patch(
        target='rotkehlchen.db.dbhandler.FREE_TRADES_LIMIT',
        new=2,
    )
    with limit_patch:
        returned_trades, total_found = data.db.get_trades_and_limit_info(
            filter_query=TradesFilterQuery.make(from_ts=1, to_ts=2),
            has_premium=False,
        )
    # trades should be the second one since the free limit includes the last 2 only
    assert total_found == 2, 'total found for filter should be 2'
    assert len(returned_trades) == 1
    assert_trades_equal(returned_trades[0], trades[1])
