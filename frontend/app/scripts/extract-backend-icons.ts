/**
 * Extracts icon names from backend Python files for use in vite.config.ts.
 * Falls back to a cached TypeScript file when the backend directory is unavailable (e.g., Docker builds).
 */

import type { Plugin } from 'vite';
import { existsSync, readdirSync, readFileSync, statSync, writeFileSync } from 'node:fs';
import { join, resolve } from 'node:path';
import process from 'node:process';
import { RuiIcons } from '@rotki/ui-library';
import consola from 'consola';

const GENERATED_FILE = '../backend-icons.generated.ts';
const validIconsSet = new Set<string>(RuiIcons);

interface IconLocation {
  file: string;
  line: number;
  icon: string;
}

function getGeneratedFilePath(): string {
  return join(import.meta.dirname, GENERATED_FILE);
}

function generateFileContent(icons: string[]): string {
  const iconsList = icons.map(icon => `  '${icon}',`).join('\n');
  return `/* eslint-disable */
/* prettier-ignore */
// @ts-nocheck
// Auto-generated file - DO NOT EDIT MANUALLY
// Generated by extract-backend-icons.ts
// To regenerate, run: pnpm run generate:backend-icons

export const backendIcons: string[] = [
${iconsList}
] as const;
`;
}

function writeGeneratedIconsFile(icons: string[]): void {
  const filePath = getGeneratedFilePath();
  const content = generateFileContent(icons);
  writeFileSync(filePath, content, 'utf-8');
  consola.success(`Generated ${GENERATED_FILE} with ${icons.length} icons`);
}

function backendDirectoryExists(projectRoot: string): boolean {
  return existsSync(join(projectRoot, 'rotkehlchen'));
}

function getPythonFiles(dir: string): string[] {
  const files: string[] = [];

  for (const entry of readdirSync(dir)) {
    const fullPath = join(dir, entry);
    const stat = statSync(fullPath);

    if (stat.isDirectory()) {
      if (entry === 'tests' || entry === '__pycache__')
        continue;
      files.push(...getPythonFiles(fullPath));
    }
    else if (entry.endsWith('.py') && !entry.startsWith('test_')) {
      files.push(fullPath);
    }
  }

  return files;
}

function extractIconsWithLocations(filePath: string): IconLocation[] {
  const locations: IconLocation[] = [];
  const content = readFileSync(filePath, 'utf-8');
  const lines = content.split('\n');
  const linePattern = /["']lu-([\da-z-]+)["']/g;

  for (const [lineIndex, line] of lines.entries()) {
    for (const match of line.matchAll(linePattern)) {
      locations.push({
        file: filePath,
        line: lineIndex + 1,
        icon: `lu-${match[1]}`,
      });
    }
  }

  return locations;
}

function scanBackendIcons(projectRoot: string): { icons: string[]; invalidIcons: IconLocation[] } {
  const backendDir = join(projectRoot, 'rotkehlchen');
  const pythonFiles = getPythonFiles(backendDir);
  const allIcons = new Set<string>();
  const invalidIcons: IconLocation[] = [];

  for (const file of pythonFiles) {
    for (const location of extractIconsWithLocations(file)) {
      allIcons.add(location.icon);
      if (!validIconsSet.has(location.icon))
        invalidIcons.push(location);
    }
  }

  return {
    icons: [...allIcons].sort(),
    invalidIcons,
  };
}

function readGeneratedIcons(): string[] {
  const generatedFilePath = getGeneratedFilePath();
  if (!existsSync(generatedFilePath))
    return [];

  const content = readFileSync(generatedFilePath, 'utf-8');
  const match = content.match(/export const backendIcons: string\[] = \[([\S\s]*?)] as const;/);
  if (match) {
    const iconsStr = match[1];
    return [...iconsStr.matchAll(/'([^']+)'/g)].map(m => m[1]);
  }
  return [];
}

function updateGeneratedFileIfNeeded(newIcons: string[]): boolean {
  const existingIcons = readGeneratedIcons();
  const sortedNewIcons = [...newIcons].sort();

  if (existingIcons.length === sortedNewIcons.length
    && existingIcons.every((icon, i) => icon === sortedNewIcons[i])) {
    return false;
  }

  writeGeneratedIconsFile(sortedNewIcons);
  return true;
}

function updateBackendIconsCache(projectRoot: string): void {
  if (!backendDirectoryExists(projectRoot))
    return;

  const scanResult = scanBackendIcons(projectRoot);
  const wasUpdated = updateGeneratedFileIfNeeded(scanResult.icons);
  if (wasUpdated)
    consola.info(`Updated ${GENERATED_FILE} with ${scanResult.icons.length} icons`);
}

/**
 * Vite plugin to update backend icons cache when the build starts.
 */
export function backendIconsCachePlugin(projectRoot: string): Plugin {
  return {
    name: 'backend-icons-cache',
    buildStart() {
      updateBackendIconsCache(projectRoot);
    },
  };
}

// CLI entry point
if (process.argv[1] === import.meta.filename) {
  const projectRoot = resolve(import.meta.dirname, '../../..');
  const shouldGenerate = process.argv.includes('--generate');

  consola.info('Scanning backend files for icons...');
  const result = scanBackendIcons(projectRoot);

  consola.info(`Found ${result.icons.length} unique icons:`);
  for (const icon of result.icons)
    consola.log(`  - ${icon}`);

  if (result.invalidIcons.length > 0) {
    consola.warn(`\nFound ${result.invalidIcons.length} invalid icon(s):`);
    const byIcon = new Map<string, IconLocation[]>();
    for (const loc of result.invalidIcons) {
      const existing = byIcon.get(loc.icon) || [];
      existing.push(loc);
      byIcon.set(loc.icon, existing);
    }

    for (const [icon, locations] of [...byIcon.entries()].sort((a, b) => a[0].localeCompare(b[0]))) {
      consola.warn(`  ${icon}:`);
      for (const loc of locations) {
        const relativePath = loc.file.replace(`${projectRoot}/`, '');
        consola.warn(`    - ${relativePath}:${loc.line}`);
      }
    }
  }
  else {
    consola.success('All icons are valid');
  }

  if (shouldGenerate)
    writeGeneratedIconsFile(result.icons);
}
