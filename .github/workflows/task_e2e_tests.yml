name: E2E tests

on:
  workflow_call:
    secrets:
      CODECOV_TOKEN:
        required: false
      ETHERSCAN_API_KEY:
        required: false

permissions: { }

jobs:
  build-frontend:
    name: 'Build Frontend'
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 2
          persist-credentials: false

      - name: Load env
        uses: rotki/action-env@v3
        with:
          env_file: .github/.env.ci

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          package_json_file: frontend/package.json

      - name: Setup node
        uses: actions/setup-node@v4
        with:
          node-version-file: 'frontend/.nvmrc'
          cache: 'pnpm'
          cache-dependency-path: 'frontend/pnpm-lock.yaml'

      - name: Restore dependencies
        working-directory: ./frontend
        run: pnpm install --frozen-lockfile

      - name: Build frontend
        working-directory: ./frontend/app
        env:
          VITE_BACKEND_URL: http://127.0.0.1:30302
          VITE_COLIBRI_URL: http://127.0.0.1:30303
          VITE_COVERAGE: true
        run: pnpm run build:app --mode e2e

      - name: Upload frontend build
        uses: actions/upload-artifact@v4
        with:
          name: frontend-dist
          path: frontend/app/dist
          retention-days: 1

  build-colibri:
    name: 'Build Colibri'
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 2
          persist-credentials: false

      - name: Cache Colibri binary
        id: colibri-cache
        uses: actions/cache@v4
        with:
          path: colibri/target/release/colibri
          key: ${{ runner.os }}-colibri-${{ hashFiles('colibri/Cargo.lock', 'colibri/Cargo.toml', 'colibri/build.rs', 'colibri/src/**') }}

      - name: Setup Rust
        if: steps.colibri-cache.outputs.cache-hit != 'true'
        uses: dtolnay/rust-toolchain@stable

      - name: Build Colibri
        if: steps.colibri-cache.outputs.cache-hit != 'true'
        working-directory: ./colibri
        run: cargo build --release

      - name: Upload Colibri binary
        uses: actions/upload-artifact@v4
        with:
          name: colibri-binary
          path: colibri/target/release/colibri
          retention-days: 1

  e2e:
    name: '${{ matrix.group }}'
    needs: [ build-frontend, build-colibri ]
    env:
      CI: true
      GROUP: ${{ matrix.group }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        group: [ app, settings, balances ]
    permissions:
      actions: write
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 2
          persist-credentials: false

      - name: Load env
        uses: rotki/action-env@v3
        with:
          env_file: .github/.env.ci

      - name: Setup python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          package_json_file: frontend/package.json

      - name: Setup node
        uses: actions/setup-node@v4
        with:
          node-version-file: 'frontend/.nvmrc'
          cache: 'pnpm'
          cache-dependency-path: 'frontend/pnpm-lock.yaml'

      - name: Store test data
        uses: actions/cache@v4
        with:
          path: |
            ./frontend/app/.e2e/data/icons
            ./frontend/app/.e2e/data/global_data
          key: ${{ runner.os }}-e2e-data-${{ hashFiles('rotkehlchen/data/global.db') }}

      - name: Install uv
        uses: astral-sh/setup-uv@v5
        with:
          enable-cache: true
          version: ${{ env.UV_VERSION }}
          cache-dependency-glob: "uv.lock"

      - name: Setup backend
        run: uv sync

      - name: Restore dependencies
        working-directory: ./frontend
        run: pnpm install --frozen-lockfile

      - name: Download frontend build
        uses: actions/download-artifact@v4
        with:
          name: frontend-dist
          path: frontend/app/dist

      - name: Download Colibri binary
        uses: actions/download-artifact@v4
        with:
          name: colibri-binary
          path: colibri/target/release

      - name: Make Colibri executable
        run: chmod +x colibri/target/release/colibri

      - name: Cache Playwright browsers
        id: playwright-cache
        uses: actions/cache@v4
        with:
          path: ~/.cache/ms-playwright
          key: ${{ runner.os }}-playwright-${{ hashFiles('frontend/pnpm-lock.yaml') }}

      - name: Install Playwright browsers
        if: steps.playwright-cache.outputs.cache-hit != 'true'
        working-directory: ./frontend/app
        run: npx playwright install chromium

      - name: Install Playwright system dependencies
        working-directory: ./frontend/app
        run: npx playwright install-deps chromium

      - name: Run e2e tests
        timeout-minutes: 20
        env:
          ETHERSCAN_API_KEY: ${{ secrets.ETHERSCAN_API_KEY }}
          GROUP: ${{ matrix.group }}
          E2E_COVERAGE: true
          VITE_COVERAGE: true
        run: pnpm run test:e2e --project=chromium
        working-directory: ./frontend/app

      - name: Generate coverage report
        if: success()
        working-directory: ./frontend/app
        run: pnpm run test:e2e:coverage:report

      - name: Upload coverage to Codecov
        if: success()
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./frontend/app/tests/e2e/coverage/lcov.info
          flags: e2e-${{ matrix.group }}
          fail_ci_if_error: false

      - name: Upload test artifacts
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: test-artifacts-${{ runner.os }}-${{ matrix.group }}
          path: ./frontend/app/tests/e2e/test-results

      - name: Upload backend logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: backend-logs-${{ runner.os }}-${{ matrix.group }}
          path: ./frontend/app/.e2e/logs/*.log

      - name: Annotate backend log errors
        if: always()
        shell: bash
        run: |
          # Sanitize content to prevent log injection and annotation spoofing
          sanitize() {
            printf '%s' "$1" | tr '\n\r' ' ' | sed 's/^::/: :/g; s/|::/|: :/g'
          }

          shopt -s nullglob
          for logfile in ./frontend/app/.e2e/logs/*.log; do
            [[ -f "$logfile" ]] || continue
            filename=$(basename "$logfile")

            # Find Python tracebacks - capture the line number and extract the error type from following lines
            while IFS=: read -r linenum _; do
              # Get the traceback context (next 50 lines) to find the actual error
              error_line=$(tail -n +"$linenum" "$logfile" | head -n 50 | grep -m 1 -E "^\w+Error:|^\w+Exception:|^\w+Warning:" | head -c 200)
              if [[ -n "$error_line" ]]; then
                error_line=$(sanitize "$error_line")
                echo "::error file=$filename,line=$linenum::Python Traceback: $error_line"
              else
                echo "::error file=$filename,line=$linenum::Python Traceback found - check backend-logs-${{ runner.os }}-${{ matrix.group }} artifact"
              fi
            done < <(grep -n "Traceback (most recent call last)" "$logfile" 2>/dev/null || true)

            # Find ERROR level log messages (common Python logging format)
            while IFS=: read -r linenum content; do
              short_content=$(sanitize "$(echo "$content" | head -c 250)")
              echo "::error file=$filename,line=$linenum::$short_content"
            done < <(grep -n -E " ERROR " "$logfile" 2>/dev/null | head -n 20 || true)

            # Find CRITICAL level log messages
            while IFS=: read -r linenum content; do
              short_content=$(sanitize "$(echo "$content" | head -c 250)")
              echo "::error file=$filename,line=$linenum::$short_content"
            done < <(grep -n -E " CRITICAL " "$logfile" 2>/dev/null | head -n 10 || true)
          done